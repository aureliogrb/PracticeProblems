/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package euler;

import practice.Primes;
import practice.Utilities;
import static practice.Utilities.*;
import static practice.PrimeFactors.*;
import java.io.IOException;
import java.math.BigInteger;
import java.nio.charset.Charset;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.Month;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.function.IntToLongFunction;
import java.util.function.Predicate;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Aurelio
 * Source of problems: https://projecteuler.net/ 
 */
public class Problems001to050 {

    public int problem01() {
        //        If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
        //        Find the sum of all the multiples of 3 or 5 below 1000.

        int sum = 0;

        for (int i = 1; i < 1000; i++) {
            if (((i % 3) == 0) || ((i % 5) == 0)) {
                sum += i;
            }
        }
        return sum;
    }

    public int problem02() {

        //        Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
        //
        //        1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
        //
        //        By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

        int a, b, aux, evensum;

        a = 1;
        b = 2;

        evensum = 0;

        while (b < 4_000_000) {

            //Add the even ones
            if (b % 2 == 0) {
                evensum += b;
            }
            //Calculate the next value
            aux = a + b;

            a = b;
            b = aux;

        }

        return evensum;

    }

    public long problem03() {
        //The prime factors of 13195 are 5, 7, 13 and 29.
        //
        //What is the largest prime factor of the number 600851475143 ?

        long n = 600851475143L;

        //n = 1000000;

        long largest = 0L;

        for (long i = 2; i * i <= n; i++) {
            while (n % i == 0) {
                n /= i;
                largest = i;
            }
            if (n > 1) {
                largest = n;
            }
        }
        return largest;
    }

    public int problem04() {

        //A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
        //Find the largest palindrome made from the product of two 3-digit numbers.
        int max = 0;

        for (int a = 999; a > 99; a--) {
            for (int b = 999; b > 99; b--) {

                if (isPalindrome(a * b) && (a * b > max)) {
                    max = (a * b);
                }
            }
        }
        return max;
    }

    

    public int problem05() {
        //2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
        //
        //What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

        HashMap<Long, Long> factors = calculatePrimeFactors(2);

        for (int i = 3; i <= 20; i++) {
            factors = lowestCommonMultiple(factors, calculatePrimeFactors(i));
        }
        return (int) valuefromPrimeFactors(factors);

    }

    

   

 
    public long problem06() {

        //The sum of the squares of the first ten natural numbers is,
        //12 + 22 + ... + 102 = 385
        //
        //The square of the sum of the first ten natural numbers is,
        //(1 + 2 + ... + 10)2 = 552 = 3025
        //
        //Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.
        //
        //Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
        int val = 100;

        long sum = 0;
        long sqrs = 0;
        for (int i = 1; i <= val; i++) {
            sqrs += i * i;
            sum += i;
        }
        return sum * sum - sqrs;
    }

    public long problem07() {

        //By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
        //
        //What is the 10 001st prime number?
        //Initialize with a non-prime so the first pass give you "the first"
        long prime = 1;

        for (int i = 1; i <= 10001; i++) {
            //System.out.println(prime);
            prime = Primes.nextPrime(prime);
        }
        return prime;

    }

    public long problem08() {

        //Find the greatest product of five consecutive digits in the 1000-digit number.
        //
        //73167176531330624919225119674426574742355349194934
        //96983520312774506326239578318016984801869478851843
        //85861560789112949495459501737958331952853208805511
        //12540698747158523863050715693290963295227443043557
        //66896648950445244523161731856403098711121722383113
        //62229893423380308135336276614282806444486645238749
        //30358907296290491560440772390713810515859307960866
        //70172427121883998797908792274921901699720888093776
        //65727333001053367881220235421809751254540594752243
        //52584907711670556013604839586446706324415722155397
        //53697817977846174064955149290862569321978468622482
        //83972241375657056057490261407972968652414535100474
        //82166370484403199890008895243450658541227588666881
        //16427171479924442928230863465674813919123162824586
        //17866458359124566529476545682848912883142607690042
        //24219022671055626321111109370544217506941658960408
        //07198403850962455444362981230987879927244284909188
        //84580156166097919133875499200524063689912560717606
        //05886116467109405077541002256983155200055935729725
        //71636269561882670428252483600823257530420752963450
        String numbers = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450";
        System.out.println(numbers);
        int Longest = 0;
        for (int i = 0; i <= 995; i++) {
            int CurrValue = 1;

            for (int digit = 0; digit < 5; digit++) {

                CurrValue = CurrValue * Integer.parseInt(Character.toString(numbers.charAt(i + digit)));

            }
            if (CurrValue > Longest) {
                Longest = CurrValue;
                //System.out.println(Longest + ": " + numbers.substring(i, i + 5));
            }

        }
        return Longest;

    }

    public long problem09() {

        //A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
        //a^2 + b^2 = c^2
        //
        //For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
        //
        //There exists exactly one Pythagorean triplet for which a + b + c = 1000.
        
        //Find the product abc.
        //A has to be < 333 for a<b<c and a+b+c = 1000
        for (int a = 1; a < 333; a++) // since a<b<c then b < (1000 -a) / 2 
        {
            for (int b = a; b < (1000 - a) / 2; b++) {
                int c = a * a + b * b;
                double aux = Math.sqrt(c);
                if (aux == Math.round(aux)) {
                    c = (int) aux;
                    //System.out.println(a + ", " + b + ", " + c + ": " + (a + b + c));
                    if (a + b + c == 1000) {
                        return a * b * c;
                    }
                }
            }
        }

        return 0;
    }

    public long problem10() {
        //The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
        //Find the sum of all the primes below two million.

        long sumOfPrimes;

        int target = 2000000;

        sumOfPrimes = 0;
        long primeNum = 2;

        while (primeNum < target) {
            sumOfPrimes += primeNum;
            primeNum = Primes.nextPrime(primeNum);

        }
        return sumOfPrimes;

    }

    public int problem11() {

        //In the 20×20 grid below, four numbers along a diagonal line have been marked in red.
        //
        //08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
        //49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
        //81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
        //52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
        //22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
        //24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
        //32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
        //67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
        //24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
        //21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
        //78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
        //16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
        //86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
        //19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
        //04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
        //88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
        //04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
        //20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
        //20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
        //01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
        //
        //The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
        //
        //What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?
        int numbers[][] = {{8, 2, 22, 97, 38, 15, 0, 40, 0, 75, 4, 5, 7, 78, 52, 12, 50, 77, 91, 8},
        {49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 4, 56, 62, 0},
        {81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 3, 49, 13, 36, 65},
        {52, 70, 95, 23, 4, 60, 11, 42, 69, 24, 68, 56, 1, 32, 56, 71, 37, 2, 36, 91},
        {22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80},
        {24, 47, 32, 60, 99, 3, 45, 2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50},
        {32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70},
        {67, 26, 20, 68, 2, 62, 12, 20, 95, 63, 94, 39, 63, 8, 40, 91, 66, 49, 94, 21},
        {24, 55, 58, 5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72},
        {21, 36, 23, 9, 75, 0, 76, 44, 20, 45, 35, 14, 0, 61, 33, 97, 34, 31, 33, 95},
        {78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 3, 80, 4, 62, 16, 14, 9, 53, 56, 92},
        {16, 39, 5, 42, 96, 35, 31, 47, 55, 58, 88, 24, 0, 17, 54, 24, 36, 29, 85, 57},
        {86, 56, 0, 48, 35, 71, 89, 7, 5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58},
        {19, 80, 81, 68, 5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 4, 89, 55, 40},
        {4, 52, 8, 83, 97, 35, 99, 16, 7, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66},
        {88, 36, 68, 87, 57, 62, 20, 72, 3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69},
        {4, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 8, 46, 29, 32, 40, 62, 76, 36},
        {20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 4, 36, 16},
        {20, 73, 35, 29, 78, 31, 90, 1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 5, 54},
        {1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 1, 89, 19, 67, 48}};

        int maxProd = 0;

        for (int x = 0; x < 20; x++) {
            for (int y = 0; y < 20; y++) {
                for (int dir = 0; dir < 4; dir++) {
                    int compVal = computeValue(numbers, x, y, dir);
                    if (compVal > maxProd) {
                        maxProd = compVal;
                    }
                }
            }
        }

        return maxProd;
    }

    private int computeValue(int numbers[][], int x, int y, int direction) {
        int dirX = 0, dirY = 0;

        switch (direction) {
            case 0:
                dirX = 1;
                dirY = 0;
                break;
            case 1:
                dirX = 1;
                dirY = 1;
                break;
            case 2:
                dirX = 0;
                dirY = 1;
                break;
            case 3:
                dirX = -1;
                dirY = 1;
                break;
        }
        //Check for out of bounds
        if ((x + 3 * dirX < 0) || (x + 3 * dirX >= numbers.length) || (y + 3 * dirY < 0) || (y + 3 * dirY >= numbers[x].length)) {
            return 0;
        } else {
            int prod = 1;
            for (int i = 0; i < 4; i++) {
                prod *= numbers[x + dirX * i][y + dirY * i];
            }
            return prod;
        }
    }

    public int problem12() {

        //The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
        //
        //1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
        //
        //Let us list the factors of the first seven triangle numbers:
        //
        //     1: 1
        //     3: 1,3
        //     6: 1,2,3,6
        //    10: 1,2,5,10
        //    15: 1,3,5,15
        //    21: 1,3,7,21
        //    28: 1,2,4,7,14,28
        //
        //We can see that 28 is the first triangle number to have over five divisors.
        //
        //What is the value of the first triangle number to have over five hundred divisors?
        int i = 1;
        while (true) {
            //The sume of all integers from 1 to i
            int sum = (1 + i) * i / 2;
            int divCount = divisorCount(sum);
            //System.out.println(i + " " + sum + " " + divCount);
            if (divCount > 500) {
                return sum;
            }

            i++;
        }

    }

    

    public long problem13() {
        //Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
        //37107287533902102798797998220837590246510135740250
        //46376937677490009712648124896970078050417018260538
        //74324986199524741059474233309513058123726617309629
        //91942213363574161572522430563301811072406154908250
        //23067588207539346171171980310421047513778063246676
        //89261670696623633820136378418383684178734361726757
        //28112879812849979408065481931592621691275889832738
        //44274228917432520321923589422876796487670272189318
        //47451445736001306439091167216856844588711603153276
        //70386486105843025439939619828917593665686757934951
        //62176457141856560629502157223196586755079324193331
        //64906352462741904929101432445813822663347944758178
        //92575867718337217661963751590579239728245598838407
        //58203565325359399008402633568948830189458628227828
        //80181199384826282014278194139940567587151170094390
        //35398664372827112653829987240784473053190104293586
        //86515506006295864861532075273371959191420517255829
        //71693888707715466499115593487603532921714970056938
        //54370070576826684624621495650076471787294438377604
        //53282654108756828443191190634694037855217779295145
        //36123272525000296071075082563815656710885258350721
        //45876576172410976447339110607218265236877223636045
        //17423706905851860660448207621209813287860733969412
        //81142660418086830619328460811191061556940512689692
        //51934325451728388641918047049293215058642563049483
        //62467221648435076201727918039944693004732956340691
        //15732444386908125794514089057706229429197107928209
        //55037687525678773091862540744969844508330393682126
        //18336384825330154686196124348767681297534375946515
        //80386287592878490201521685554828717201219257766954
        //78182833757993103614740356856449095527097864797581
        //16726320100436897842553539920931837441497806860984
        //48403098129077791799088218795327364475675590848030
        //87086987551392711854517078544161852424320693150332
        //59959406895756536782107074926966537676326235447210
        //69793950679652694742597709739166693763042633987085
        //41052684708299085211399427365734116182760315001271
        //65378607361501080857009149939512557028198746004375
        //35829035317434717326932123578154982629742552737307
        //94953759765105305946966067683156574377167401875275
        //88902802571733229619176668713819931811048770190271
        //25267680276078003013678680992525463401061632866526
        //36270218540497705585629946580636237993140746255962
        //24074486908231174977792365466257246923322810917141
        //91430288197103288597806669760892938638285025333403
        //34413065578016127815921815005561868836468420090470
        //23053081172816430487623791969842487255036638784583
        //11487696932154902810424020138335124462181441773470
        //63783299490636259666498587618221225225512486764533
        //67720186971698544312419572409913959008952310058822
        //95548255300263520781532296796249481641953868218774
        //76085327132285723110424803456124867697064507995236
        //37774242535411291684276865538926205024910326572967
        //23701913275725675285653248258265463092207058596522
        //29798860272258331913126375147341994889534765745501
        //18495701454879288984856827726077713721403798879715
        //38298203783031473527721580348144513491373226651381
        //34829543829199918180278916522431027392251122869539
        //40957953066405232632538044100059654939159879593635
        //29746152185502371307642255121183693803580388584903
        //41698116222072977186158236678424689157993532961922
        //62467957194401269043877107275048102390895523597457
        //23189706772547915061505504953922979530901129967519
        //86188088225875314529584099251203829009407770775672
        //11306739708304724483816533873502340845647058077308
        //82959174767140363198008187129011875491310547126581
        //97623331044818386269515456334926366572897563400500
        //42846280183517070527831839425882145521227251250327
        //55121603546981200581762165212827652751691296897789
        //32238195734329339946437501907836945765883352399886
        //75506164965184775180738168837861091527357929701337
        //62177842752192623401942399639168044983993173312731
        //32924185707147349566916674687634660915035914677504
        //99518671430235219628894890102423325116913619626622
        //73267460800591547471830798392868535206946944540724
        //76841822524674417161514036427982273348055556214818
        //97142617910342598647204516893989422179826088076852
        //87783646182799346313767754307809363333018982642090
        //10848802521674670883215120185883543223812876952786
        //71329612474782464538636993009049310363619763878039
        //62184073572399794223406235393808339651327408011116
        //66627891981488087797941876876144230030984490851411
        //60661826293682836764744779239180335110989069790714
        //85786944089552990653640447425576083659976645795096
        //66024396409905389607120198219976047599490197230297
        //64913982680032973156037120041377903785566085089252
        //16730939319872750275468906903707539413042652315011
        //94809377245048795150954100921645863754710598436791
        //78639167021187492431995700641917969777599028300699
        //15368713711936614952811305876380278410754449733078
        //40789923115535562561142322423255033685442488917353
        //44889911501440648020369068063960672322193204149535
        //41503128880339536053299340368006977710650566631954
        //81234880673210146739058568557934581403627822703280
        //82616570773948327592232845941706525094512325230608
        //22918802058777319719839450180888072429661980811197
        //77158542502016545090413245809786882778948721859617
        //72107838435069186155435662884062257473692284509516
        //20849603980134001723930671666823555245252804609722
        //53503534226472524250874054075591789781264330331690

        String[] numbers = {"37107287533902102798797998220837590246510135740250",
            "46376937677490009712648124896970078050417018260538",
            "74324986199524741059474233309513058123726617309629",
            "91942213363574161572522430563301811072406154908250",
            "23067588207539346171171980310421047513778063246676",
            "89261670696623633820136378418383684178734361726757",
            "28112879812849979408065481931592621691275889832738",
            "44274228917432520321923589422876796487670272189318",
            "47451445736001306439091167216856844588711603153276",
            "70386486105843025439939619828917593665686757934951",
            "62176457141856560629502157223196586755079324193331",
            "64906352462741904929101432445813822663347944758178",
            "92575867718337217661963751590579239728245598838407",
            "58203565325359399008402633568948830189458628227828",
            "80181199384826282014278194139940567587151170094390",
            "35398664372827112653829987240784473053190104293586",
            "86515506006295864861532075273371959191420517255829",
            "71693888707715466499115593487603532921714970056938",
            "54370070576826684624621495650076471787294438377604",
            "53282654108756828443191190634694037855217779295145",
            "36123272525000296071075082563815656710885258350721",
            "45876576172410976447339110607218265236877223636045",
            "17423706905851860660448207621209813287860733969412",
            "81142660418086830619328460811191061556940512689692",
            "51934325451728388641918047049293215058642563049483",
            "62467221648435076201727918039944693004732956340691",
            "15732444386908125794514089057706229429197107928209",
            "55037687525678773091862540744969844508330393682126",
            "18336384825330154686196124348767681297534375946515",
            "80386287592878490201521685554828717201219257766954",
            "78182833757993103614740356856449095527097864797581",
            "16726320100436897842553539920931837441497806860984",
            "48403098129077791799088218795327364475675590848030",
            "87086987551392711854517078544161852424320693150332",
            "59959406895756536782107074926966537676326235447210",
            "69793950679652694742597709739166693763042633987085",
            "41052684708299085211399427365734116182760315001271",
            "65378607361501080857009149939512557028198746004375",
            "35829035317434717326932123578154982629742552737307",
            "94953759765105305946966067683156574377167401875275",
            "88902802571733229619176668713819931811048770190271",
            "25267680276078003013678680992525463401061632866526",
            "36270218540497705585629946580636237993140746255962",
            "24074486908231174977792365466257246923322810917141",
            "91430288197103288597806669760892938638285025333403",
            "34413065578016127815921815005561868836468420090470",
            "23053081172816430487623791969842487255036638784583",
            "11487696932154902810424020138335124462181441773470",
            "63783299490636259666498587618221225225512486764533",
            "67720186971698544312419572409913959008952310058822",
            "95548255300263520781532296796249481641953868218774",
            "76085327132285723110424803456124867697064507995236",
            "37774242535411291684276865538926205024910326572967",
            "23701913275725675285653248258265463092207058596522",
            "29798860272258331913126375147341994889534765745501",
            "18495701454879288984856827726077713721403798879715",
            "38298203783031473527721580348144513491373226651381",
            "34829543829199918180278916522431027392251122869539",
            "40957953066405232632538044100059654939159879593635",
            "29746152185502371307642255121183693803580388584903",
            "41698116222072977186158236678424689157993532961922",
            "62467957194401269043877107275048102390895523597457",
            "23189706772547915061505504953922979530901129967519",
            "86188088225875314529584099251203829009407770775672",
            "11306739708304724483816533873502340845647058077308",
            "82959174767140363198008187129011875491310547126581",
            "97623331044818386269515456334926366572897563400500",
            "42846280183517070527831839425882145521227251250327",
            "55121603546981200581762165212827652751691296897789",
            "32238195734329339946437501907836945765883352399886",
            "75506164965184775180738168837861091527357929701337",
            "62177842752192623401942399639168044983993173312731",
            "32924185707147349566916674687634660915035914677504",
            "99518671430235219628894890102423325116913619626622",
            "73267460800591547471830798392868535206946944540724",
            "76841822524674417161514036427982273348055556214818",
            "97142617910342598647204516893989422179826088076852",
            "87783646182799346313767754307809363333018982642090",
            "10848802521674670883215120185883543223812876952786",
            "71329612474782464538636993009049310363619763878039",
            "62184073572399794223406235393808339651327408011116",
            "66627891981488087797941876876144230030984490851411",
            "60661826293682836764744779239180335110989069790714",
            "85786944089552990653640447425576083659976645795096",
            "66024396409905389607120198219976047599490197230297",
            "64913982680032973156037120041377903785566085089252",
            "16730939319872750275468906903707539413042652315011",
            "94809377245048795150954100921645863754710598436791",
            "78639167021187492431995700641917969777599028300699",
            "15368713711936614952811305876380278410754449733078",
            "40789923115535562561142322423255033685442488917353",
            "44889911501440648020369068063960672322193204149535",
            "41503128880339536053299340368006977710650566631954",
            "81234880673210146739058568557934581403627822703280",
            "82616570773948327592232845941706525094512325230608",
            "22918802058777319719839450180888072429661980811197",
            "77158542502016545090413245809786882778948721859617",
            "72107838435069186155435662884062257473692284509516",
            "20849603980134001723930671666823555245252804609722",
            "53503534226472524250874054075591789781264330331690"};

        int[] results = new int[50];
        //The array list will have the resuls of our calculations
        for (int i = 49; i >= 0; i--) { //for each digit
            int sum = 0;
            for (int numCount = 0; numCount < 100; numCount++) {// all numbers
                sum += Integer.valueOf(Character.toString(numbers[numCount].charAt(i)));
            }

            results[i] += sum;
            //Before moving to the next number "pass" everything but the last digit to the next value
            if (i > 0) {
                results[i - 1] += results[i] / 10;
                results[i] %= 10;
            }
        }

        //Just by printing the result array I could figure it out
        //but I want to find the value programmatically as a number, not a string.
        //We need to find out how many digits on the first one, all others have 1 digit;
        //Results [0] is the only one that might have more than a single digit
        int sizeofLast = (int) Math.ceil(Math.log10(results[0]));
        long value = (long) ((long) results[0] * Math.pow(10, 10 - sizeofLast));

        for (int i = 1; i + sizeofLast <= 10; i++) {
            value += ((long) results[i] * Math.pow(10, 10 - (sizeofLast + i)));
        }

        return value;

    }

    public int problem14() {

        //The following iterative sequence is defined for the set  of positive  {
        //integers:
        //
        //  n → n / 2 (n is even)
        //  n → 3n + 1 (n is odd
        //       
        //
        //Using the rule above and starting with 13, we generate the following sequence:
        // 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
        //
        //It can be seen that this sequence(starting at 13 and finishing at 1) contains 10 terms.Although it has not been proved yet(Collatz Problem
        // ), it is thought that all starting numbers finish at 1.
        //
        //Which starting number
        // , under one million
        //, produces the longest chain?
        //
        //NOTE:
        //Once the chain starts the terms are allowed to go above one million
        int max = 1;
        int start = 1;
        int count;
        for (int i = 1000000; i > 2; i--) {
            count = collatzCount(i);
            if (count > max) {
                //System.out.println(i + " size " + count);
                max = count;
                start = i;
            }
        }

        return start;
    }

    public int collatzCount(int num) {

        int count = 1;
        long collatz = num; //if you use int to calculate this it will fail
        while (collatz != 1) {
            collatz = (collatz % 2 == 0) ? (collatz / 2) : (collatz * 3) + 1;
            count++;
        }
        return count;

    }

    public long problem15() {
        //        Starting in the top left corner of a 2×2 grid
        //        , and only being able to move to the right and down
        //        , there are exactly 6 routes to the bottom right corner
        //       How many such routes are there through a 20×20 grid ?

        long[][] pathCount = new long[21][21];

        for (int i = 0; i < 21; i++) {
            //initialize the edges, there is only one way to get to each edge, straight down or straight right
            pathCount[0][i] = 1;
            pathCount[i][0] = 1;
        }
        // Now walk through each path adding the numbers of ways to reach it.  
        walkPaths(pathCount, 1, 1);
        return pathCount[20][20];
    }

    private void walkPaths(long[][] pathCount, int x, int y) {
        //First check that I have the data I need to proceed.
        long prevX = pathCount[x - 1][y];
        long prevY = pathCount[x][y - 1];
        if (prevX == 0 || prevY == 0) {
            //Skip this, we will come back to it later

        } else {
            pathCount[x][y] = prevX + prevY;
            //System.out.println("Path for " + x + ", " + y + ": " + pathCount[x][y]);
            //Keep going left;
            if (x < 20) {
                walkPaths(pathCount, x + 1, y);
            }
            //Keep going down;
            if (y < 20) {
                walkPaths(pathCount, x, y + 1);
            }
        }
    }

    public long problem15a() {
        //Fails to compute the factorial of 40.
        return binomialCoeficient(40, 20);
    }

    public long binomialCoeficient(int n, int k) {
        if (n >= k && k > 0) {
            return factorial(n) / factorial(n - k) * factorial(k);
        } else {
            return 0;
        }
    }

    public long problem16() {

        //2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
        //
        //What is the sum of the digits of the number 2^1000?
        int[] number = new int[100];
        for (int i = 1; i < 100; i++) {
            number[i] = 0;
        }
        number[0] = 1;

        for (int i = 1; i <= 1000; i++) {
            doubleArray(number);
        }
        //printvalues(number, 9);

        //Now sum all the digits
        int sum = 0;
        for (int i = 0; i < 100; i++) {
            sum += sumofDigits(number[i]);
        }
        return sum;
    }

    public long problem16a() {
        //Using big int;
        BigInteger prod = BigInteger.valueOf(2L);

        prod = prod.pow(1000);
        //System.out.println(prod);
        return sumofDigits(prod);

    }

    public void doubleArray(int[] numbers) {
        int base = 1_000_000_000;
        //double a number expressed as groups of 9 digits.
        for (int i = 0; i < 100; i++) {
            //double the number
            numbers[i] *= 2;
        }
        //Now see if any of the numbers needs to be "cleaned"
        for (int i = 0; i < 99; i++) {
            if (numbers[i] >= base) { //pass the "rest" to the next position
                numbers[i + 1] += numbers[i] / base;
                numbers[i] %= base;
            }
        }
        if (numbers[99] > base) {
            System.out.println("Overflow!");
        }
    }

   

    private void printvalues(int[] numbers, int len) {
        StringBuilder newstring = new StringBuilder();
        boolean started = false;
        StringBuilder padding = new StringBuilder(len);
        for (int i = 1; i <= len; i++) {
            padding.append("0");
        }
        for (int j = numbers.length - 1; j >= 0; j--) {
            if (started || numbers[j] > 0) {
                started = true;
                String val = padding.toString() + numbers[j];
                newstring.append(val.substring(val.length() - len));
            }
        }
        System.out.println(newstring.toString());

    }

    public int problem17() {
        //If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
        //
        //If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?
        //
        //NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of "and" when writing out numbers is in compliance with British usage.
        int sum = 0;
        String value;
        for (int i = -100; i <= 1000; i++) {
            value = sayInt(i);
            sum += value.replace(" ", "").replace("-", "").length();
            //System.out.print(value.replace(" ", "").replace("-", "").length() + "   :");
            //System.out.println(value + "  ");
            //System.out.println(value.replace(" ", "").replace("-", ""));
        }
        return sum;
    }

    private String sayInt(int value) {
        if (value < 0) {
            return ("Negative " + sayInt(-value));
        }
        if (value > 9999) {
            return ("Can't go higher than 9,999");
        }
        if (value < 20) {
            switch (value) {
                case 0:
                    return "zero";
                case 1:
                    return "one";
                case 2:
                    return "two";
                case 3:
                    return "three";
                case 4:
                    return "four";
                case 5:
                    return "five";
                case 6:
                    return "six";
                case 7:
                    return "seven";
                case 8:
                    return "eight";
                case 9:
                    return "nine";
                case 10:
                    return "ten";
                case 11:
                    return "eleven";
                case 12:
                    return "twelve";
                case 13:
                    return "thirteen";
                case 14:
                    return "fourteen";
                case 15:
                    return "fifteen";
                case 16:
                    return "sixteen";
                case 17:
                    return "seventeen";
                case 18:
                    return "eighteen";
                case 19:
                    return "nineteen";
            }
        }

        //For values between 20 and 99 we need the "decimal" value;
        if (value < 100) {
            String decValue = "";
            switch (value / 10) {
                case 2:
                    decValue = "twenty";
                    break;
                case 3:
                    decValue = "thirty";
                    break;
                case 4:
                    decValue = "forty";
                    break;
                case 5:
                    decValue = "fifty";
                    break;
                case 6:
                    decValue = "sixty";
                    break;
                case 7:
                    decValue = "seventy";
                    break;
                case 8:
                    decValue = "eighty";
                    break;
                case 9:
                    decValue = "ninety";
                    break;

            }
            if (value % 10 != 0) {
                return decValue + "-" + sayInt(value % 10);
            } else {
                return decValue;
            }

        }
        //For values between 100 and 999 we need the hundreds;
        if (value < 1000) {
            int hundredsVal = value / 100;
            if (value % 100 != 0) {
                return sayInt(hundredsVal) + " hundred and " + sayInt(value % 100);
            } else {
                return sayInt(hundredsVal) + " hundred";
            }
        }
        //For values betweeb 1000 and 9999 we need thousands;
        if (value < 9999) {
            int thousandVal = value / 1000;
            //If there are no "hundreds" add the "and" before the decimals.
            if (value % 1000 > 99) {
                return sayInt(thousandVal) + " thousand " + sayInt(value % 1000);
            } else {
                if (value % 1000 != 0) {
                    return sayInt(thousandVal) + " thousand and " + sayInt(value % 1000);
                } else {
                    return sayInt(thousandVal) + " thousand";
                }
            }

        }

        return "Not coded yet";
    }

    public int problem18() {
        
        //By starting at the top of the triangle below and moving to adjacent 
        //numbers on the row below, the maximum total from top to bottom is 23.
        //
        //     3
        //    7 4
        //   2 4 6
        //  8 5 9 3
        //
        //That is, 3 + 7 + 4 + 9 = 23.
        //
        //Find the maximum total from top to bottom of the triangle below:
        //
        //                     75
        //                    95 64
        //                   17 47 82
        //                  18 35 87 10
        //                 20 04 82 47 65
        //                19 01 23 75 03 34
        //               88 02 77 73 07 63 67
        //              99 65 04 28 06 16 70 92
        //             41 41 26 56 83 40 80 70 33
        //            41 48 72 33 47 32 37 16 94 29
        //           53 71 44 65 25 43 91 52 97 51 14
        //          70 11 33 28 77 73 17 78 39 68 17 57
        //         91 71 52 38 17 14 91 43 58 50 27 29 48
        //        63 66 04 68 89 53 67 30 73 16 69 87 40 31
        //       04 62 98 27 23 09 70 98 73 93 38 53 60 04 23
        //Since we will have to read a large file for problem 67
        //lets create a function for initializing each row from a string;
        
        int numbers[][] = new int[15][];
        
        initRow(numbers, 0, "75");
        initRow(numbers, 1, "95 64");
        initRow(numbers, 2, "17 47 82");
        initRow(numbers, 3, "18 35 87 10");
        initRow(numbers, 4, "20 04 82 47 65");
        initRow(numbers, 5, "19 01 23 75 03 34");
        initRow(numbers, 6, "88 02 77 73 07 63 67");
        initRow(numbers, 7, "99 65 04 28 06 16 70 92");
        initRow(numbers, 8, "41 41 26 56 83 40 80 70 33");
        initRow(numbers, 9, "41 48 72 33 47 32 37 16 94 29");
        initRow(numbers, 10, "53 71 44 65 25 43 91 52 97 51 14");
        initRow(numbers, 11, "70 11 33 28 77 73 17 78 39 68 17 57");
        initRow(numbers, 12, "91 71 52 38 17 14 91 43 58 50 27 29 48");
        initRow(numbers, 13, "63 66 04 68 89 53 67 30 73 16 69 87 40 31");
        initRow(numbers, 14, "04 62 98 27 23 09 70 98 73 93 38 53 60 04 23");
        return maxTotalRoute (numbers);

    }

    public static void initRow(int numbers[][], int row, String value) {
        //first find the number of columns
        String values[] = value.split(" +");
        numbers[row] = new int[values.length];

        for (int i = 0; i < values.length; i++) {
            numbers[row][i] = Integer.valueOf(values[i]);
        }
    }
    
    public static int maxTotalRoute(int numbers[][]) {
        
        //Starting at the next to last row, work our way up choosing the "final" step
        for (int row = numbers.length - 2; row >= 0; row--) {
            for (int col = 0; col < numbers[row].length; col++) {
                numbers[row][col] += Math.max(numbers[row + 1][col], numbers[row + 1][col + 1]);
            }
        }
        return numbers[0][0];
        
    }

    public int problem19() {

        //You are given the following information, but you may prefer to do some research for yourself.
        //
        //    1 Jan 1900 was a Monday.
        //    Thirty days has September,
        //    April, June and November.
        //    All the rest have thirty-one,
        //    Saving February alone,
        //    Which has twenty-eight, rain or shine.
        //    And on leap years, twenty-nine.
        //    A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.
        //
        //How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?
        //Using new JDK 8 - JSR 310 dates
        LocalDate day = LocalDate.of(1901, Month.JANUARY, 1);
        int count = 0;
        while (day.getYear() < 2001) {
            if (day.getDayOfWeek() == DayOfWeek.SUNDAY) {
                count++;
            }
            day = day.plusMonths(1);
        }
        return count;
    }

    public int problem19a() {
        //using the "old" Calendar API 

        Calendar cal = new GregorianCalendar();
        cal.set(1901, Calendar.JANUARY, 1);
        //Now add months one at a time and counf it the resulting date is on a Sunday;
        int count = 0;
        while (cal.get(Calendar.YEAR) < 2001) {
            if (cal.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY) {
                count++;
            }
            cal.add(Calendar.MONTH, 1);
        }
        return count;
        //Now increment in blocks of 1 week counting the Sundays

    }

    private void multiplyArray(int[] numbers, int operand) {
        int base = 1_000_000;
        //multiples a number expressed as groups of 9 digits by a given value.
        for (int i = 0; i < numbers.length; i++) {
            //double the number
            numbers[i] *= operand;
        }
        
        //Now see if any of the numbers needs to be "cleaned"
        for (int i = 0; i < numbers.length - 2; i++) {
            if (numbers[i] >= base) { //pass the "rest" to the next position
                numbers[i + 1] += numbers[i] / base;
                numbers[i] %= base;
            }
        }
        if (numbers[numbers.length - 1] > base) {
            System.out.println("Overflow!");
        }
    }

    public int problem20() {

        //n! means n × (n − 1) × ... × 3 × 2 × 1
        //
        //For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
        //and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.
        //
        //Find the sum of the digits in the number 100!
        int numbers[] = {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        for (int i = 1; i <= 100; i++) {
            multiplyArray(numbers, i);
            //printvalues(numbers, 6);
        }
        int total = 0;
        for (int i = 0; i < numbers.length; i++) {
            total += sumofDigits(numbers[i]);
            //System.out.println(total);
        }
        return total;
    }

    public int problem20a() {

        //n! means n × (n − 1) × ... × 3 × 2 × 1
        //
        //For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
        //and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.
        //
        //Find the sum of the digits in the number 100!
        //Discovered BigInteger!
        BigInteger val = BigInteger.ONE;

        //no need to multiply to 100 since the last just adds two zeros
        for (int i = 1; i < 100; i++) {
            val = val.multiply(BigInteger.valueOf(i));
        }

        return sumofDigits(val);

    }

    

    public int problem21() {
        //Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).
        //If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair and each of a and b are called amicable numbers.
        //
        //For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.
        //
        //Evaluate the sum of all the amicable numbers under 10000.
        int sum = 0;
        int curVal;
        for (int i = 1; i < 10000; i++) {
            curVal = sumOfProperDivisors(i);
            if (i != curVal && i == sumOfProperDivisors(curVal)) {
                sum += curVal;
            }
        }
        return sum;

    }

    public int sumOfProperDivisors(int n) {
        int sum = 0;
        for (int i = 1; i <= (n + 1) / 2; i++) {
            if (n % i == 0) {
                sum += i;
            }
        }
        return sum;
    }

    public long problem22() {

        //Using words.txt (right click and 'Save Link/Target As...'), a 46K text file containing over
        //five-thousand first words, begin by sorting it into alphabetical order. Then working out the
        //alphabetical value for each name, multiply this value by its alphabetical position in the list
        //to obtain a name score
        //For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12
        //+ 9 + 14 = 53, is the 938th name in the list. So, COLIN would obtain a score of 938 × 53 =
        //49714.
        //What is the total of all the name scores in the file?         
        Path path = FileSystems.getDefault().getPath("./src", "names.txt");
        ArrayList<String> names = new ArrayList<String>();
        try {
            //Split the single line on "," and then remove the quotations.
            List<String> lines = Files.readAllLines(path, Charset.defaultCharset());
            lines.stream().map((line) -> line.split(",")).forEach((values) -> {
                for (String name : values) {
                    names.add(name.replace("\"", ""));
                }
            });
        } catch (IOException ex) {
            Logger.getLogger(Problems001to050.class.getName()).log(Level.SEVERE, null, ex);
        }
        //Now that we have the words, sort it.
        Collections.sort(names);

        long sum = 0;
        int pos = 1;

        //Traverse the array
        for (String name : names) {
            sum += name.toUpperCase().chars().map((character) -> {
                return character - 64;
            }).sum() * pos;
            pos++;
        }
        return sum;
    }

    public int problem23() {

        //A perfect number is a number for which the sum of its proper divisors is exactly equal to the
        //number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28,
        //which means that 28 is a perfect number.
        //
        //A number n is called deficient if the sum of its proper divisors is less than n and it is called
        //abundant if this sum exceeds n.
        //
        //As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be
        //written as the sum of two abundant numbers is 24. By mathematical analysis, it can be shown that
        //all integers greater than 28123 can be written as the sum of two abundant numbers. However, this
        //upper limit cannot be reduced any further by analysis even though it is known that the greatest
        //number that cannot be expressed as the sum of two abundant numbers is less than this limit.
        //
        //Find the sum of all the positive integers which cannot be written as the sum of two abundant
        //numbers
        // First: Find all the abundant numbers under  28123
        ArrayList<Integer> abundants = new ArrayList<>();
        for (int i = 12; i < 28123; i++) {
            if (sumOfProperDivisors(i) > i) {
                abundants.add(i);
            }
        }

        //Now we can just use an array of 28123 booleans
        //"tag" all the numbers that are possible to calculate 
        //as the sum of two abundants.
        boolean sumOfAbundant[] = new boolean[28123];
        for (int i = 0; i < 28123; i++) {
            sumOfAbundant[i] = false;
        }

        //Traverse all the possibe sums
        for (int i = 0; i < abundants.size(); i++) {
            for (int j = i; j < abundants.size(); j++) {
                int index = abundants.get(i) + abundants.get(j);
                if (index < 28123) {
                    sumOfAbundant[index] = true;
                }
            }
        }

        int sum = 0;
        for (int i = 0; i < 28123; i++) {
            if (!sumOfAbundant[i]) {
                sum += i;
            }
        }

        return sum;

    }

    public String problem24() {
        //A permutation is an ordered arrangement of objects. For example, 3124 is one possible
        //permutation of the digits 1, 2, 3 and 4. If all of the permutations are listed numerically or
        //alphabetically, we call it lexicographic order. The lexicographic permutations of 0, 1 and 2
        //are:
        //
        //012   021   102   120   201   210
        //
        //What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?

        ArrayList<Character> characters = new ArrayList<>();
        for (int i = 0; i <= 9; i++) {
            characters.add(String.valueOf(i).charAt(0));
            //System.out.println(characters.get(characters.size() - 1));
        }

        //Rather than calculate all the possibilities we will directly compute
        //the "correct" permutation.
        //If you sort the values the first value repeats (n-1)! times, 
        //the second value repeats (n-2)! times, etc. until you are left with
        //only 2 digit.
        int target = 1000000;

        StringBuilder value = new StringBuilder();
        while (!characters.isEmpty()) {
            if (characters.size() == 2) {
                if (target == 1) {
                    value.append(characters.get(0));
                    value.append(characters.get(1));
                } else {
                    value.append(characters.get(1));
                    value.append(characters.get(0));
                }
                characters.clear();
            } else {
                long groupsize = factorial(characters.size() - 1);
                int position;
                //Find the first value
                if (target > groupsize) {
                    if (target % groupsize == 0) {
                        position = (int) (target / groupsize) - 1;
                    } else {
                        position = (int) (target / groupsize);
                    }
                    target = (int) (target - position * groupsize);
                } else {
                    position = 0;
                }

                char charToAdd = characters.get(position);
                characters.remove(position);
                value.append(charToAdd);
            }
        }
        return value.toString();
    }

    public int problem25() {
        //The Fibonacci sequence is defined by the recurrence relation:
        //
        //    Fn = Fn-1 + Fn-2, where F1 = 1 and F2 = 1.
        //
        //Hence the first 12 terms will be:
        //
        //    F1 = 1
        //    F2 = 1
        //    F3 = 2
        //    F4 = 3
        //    F5 = 5
        //    F6 = 8
        //    F7 = 13
        //    F8 = 21
        //    F9 = 34
        //    F10 = 55
        //    F11 = 89
        //    F12 = 144
        //
        //The 12th term, F12, is the first term to contain three digits.
        //
        //What is the first term in the Fibonacci sequence to contain 1000 digits?

        BigInteger a, b, c;
        int pos;

        a = BigInteger.ONE;
        b = BigInteger.ONE;
        pos = 2;

        while (a.compareTo(BigInteger.TEN.pow(999)) < 0) {
            c = a;
            a = a.add(b);
            pos++;
            b = c;

        }
        return pos;

    }

    public int problem26() {
        //A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to
        //10 are given:
        //
        //    1/2	= 	0.5
        //    1/3	= 	0.(3)
        //    1/4	= 	0.25
        //    1/5	= 	0.2
        //    1/6	= 	0.1(6)
        //    1/7	= 	0.(142857)
        //    1/8	= 	0.125
        //    1/9	= 	0.(1)
        //    1/10	= 	0.1
        //
        //Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be seen that 1/7 has a 6-digit recurring cycle.
        //
        //Find the value of d < 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part.
        int d = 0;
        int longestCycle = 0;
        int currCycle;
        for (int i = 2; i <= 1000; i++) {
            currCycle = recurringCycle(i);
            if (currCycle > longestCycle) {
                longestCycle = currCycle;
                d = i;

            }

        }
        return d;
    }

    private int recurringCycle(int divisor) {
        final int maxSize = 10000;
        ArrayList<Integer> result = new ArrayList<Integer>();
        ArrayList<Integer> modulos = new ArrayList<Integer>();
        if (divisor < 2) {
            return 0;
        }
        //The result of 1 over any int > 1 will be 0.xxx lets leave the 0. implied
        int curvalue = 10;
        modulos.add(10);
        while (result.size() < maxSize) {
            while (curvalue < divisor) {
                curvalue *= 10;
                result.add(0);
                modulos.add(curvalue);
            }

            int nextNumber = curvalue / divisor;
            result.add(nextNumber);
            curvalue = curvalue % divisor * 10;

            if (modulos.contains(curvalue) || curvalue == 0) {

                //System.out.print("0.");
                //result.stream().forEach(System.out::print);
                //result.stream().forEach(System.out::print);
                if (curvalue != 0) {
                    //System.out.println("_");
                    return modulos.size() - modulos.indexOf(curvalue);
                } else {
                    //System.out.println();
                    return 0;

                }

            } else {
                modulos.add(curvalue);
            }
        }
        //System.out.print("0.");
        //result.stream().forEach(System.out::print);
        //System.out.println();
        return 0;
    }

    public int problem27() {
        //Euler discovered the remarkable quadratic formula:
        //
        //n² + n + 41
        //
        //It turns out that the formula will produce 40 primes for the consecutive values n = 0 to 39. However, when n = 40, 402 + 40 + 41 = 40(40 + 1) + 41 is divisible by 41, and certainly when n = 41, 41² + 41 + 41 is clearly divisible by 41.
        //
        //The incredible formula  n² - 79n + 1601 was discovered, which produces 80 primes for the consecutive values n = 0 to 79. The product of the coefficients, -79 and 1601, is -126479.
        //
        //Considering quadratics of the form:
        //
        //    n² + an + b, where |a| < 1000 and |b| < 1000
        //
        //    where |n| is the modulus/absolute value of n
        //    e.g. |11| = 11 and |-4| = 4
        //
        //Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n = 0.
        int maxCount = 0;
        int curCount;
        int a1 = 0, b1 = 0;
        for (int a = 999; a >= -999; a--) {
            for (int b = 999; b >= -999; b--) {
                curCount = countNumberOfPrimes(a, b);
                if (curCount > maxCount) {
                    maxCount = curCount;
                    a1 = a;
                    b1 = b;
                    //System.out.println(a1 + " " + b1 + " " + curCount);
                }
            }
        }
        return a1 * b1;
    }

    private int countNumberOfPrimes(int a, int b) {
        //Count how many primes are created by n² + an + b
        int i = 0;
        while (true) {

            if (Primes.isPrime((i * i + a * i + b))) {
                //System.out.println(i * i + a * i + b);
                i++;
            } else {
                break;
            }
        }
        return i;
    }

    public long problem28() {
        //        Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:
        //
        //        21 22 23 24 25
        //        20  7  8  9 10
        //        19  6  1  2 11
        //        18  5  4  3 12
        //        17 16 15 14 13
        //
        //        It can be verified that the sum of the numbers on the diagonals is 101.
        //
        //        What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?

        //Create a 1001 x 1001 matrix with the "center" being 0,0
        int SIDE = 1001;
        int HALF = (SIDE - 1) / 2;
        int values[][] = new int[SIDE][SIDE];

        //First populate the matrix
        int x, y, val;
        x = 0;
        y = 0;
        val = 1;

        values[x + HALF][y + HALF] = val++;
        for (int side = 1; side <= HALF; side++) {
            //first move to the right
            x++;
            values[x + HALF][y + HALF] = val++;

            //fill "down"
            for (int i = 0; i < side * 2 - 1; i++) {
                y--;
                values[x + HALF][y + HALF] = val++;
            }

            //Fill Left
            for (int i = 0; i < side * 2; i++) {
                x--;
                values[x + HALF][y + HALF] = val++;
            }

            //Fill up
            for (int i = 0; i < side * 2; i++) {
                y++;
                values[x + HALF][y + HALF] = val++;
            }
            //Fill right

            for (int i = 0; i < side * 2; i++) {
                x++;
                values[x + HALF][y + HALF] = val++;
            }

        }

        //Now add the diagonals
        long sum = 1;

        for (int i = 1; i <= HALF; i++) {
            sum += values[i + HALF][i + HALF];
            sum += values[i + HALF][-i + HALF];
            sum += values[-i + HALF][i + HALF];
            sum += values[-i + HALF][-i + HALF];
        }

        return sum;
    }

    public int problem29() {

        // Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
        //
        //    2^2=4, 2^3=8, 2^4=16, 2^5=32
        //    3^2=9, 3^3=27, 3^4=81, 3^5=243
        //    4^2=16, 4^3=64, 4^4=256, 4^5=1024
        //    5^2=25, 5^3=125, 5^4=625, 5^5=3125
        //
        // If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
        //
        // 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
        // How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?    
        HashSet<BigInteger> values = new HashSet<>();

        for (int a = 2; a <= 100; a++) {
            for (int b = 2; b <= 100; b++) {
                BigInteger val = BigInteger.valueOf(a);
                values.add(val.pow(b));
            }
        }
        //values.stream().sorted().forEach(System.out::println);

        return values.size();
    }

    public int problem30() {

        //Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:
        //
        //    1634 = 1^4 + 6^4 + 3^4 + 4^4
        //    8208 = 8^4 + 2^4 + 0^4 + 8^4
        //    9474 = 9^4 + 4^4 + 7^4 + 4^4
        //
        //As 1 = 1^4 is not a sum it is not included.
        //
        //The sum of these numbers is 1634 + 8208 + 9474 = 19316.
        //
        //Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.
        // 9^5 = 5,9049
        // 1 digit numbers will sum between 1 and 59049*1 = 5,9049    : 1 <= A <= 5,9049  for all A where A>=1
        // 2 digit numbers will sum between 1 and 59049*2 = 118,098   : 1 <= AB <= 118,098  for all AB where A>=1
        // 3 digit numbers will sum between 1 and 59049*3 = 177,147   : 1 <= ABC <= 177,147 for all ABC where A>=1
        // 4 digit numbers will sum between 1 and 59049*4 = 236,196   : 1 <= ABCD <= 236,196 for all ABCD where A>=1
        // 5 digit numbers will sum between 1 and 59049*5 = 295,245   : 1 <= ABCDE <= 295,245 for all ABCDE where A>=1
        // 6 digit numbers will sum between 1 and 59049*6 = 354,294   : 1 <= ABCDEF <= 354,294  for SOME. Only up to ABCDEF <= 354,294
        // 7 digit numbers will sum between 1 and 59049*7 = 413,343   : 1 <= ABCDEFG BUT ALL > 413,343 
        // So all 7 or more digit numbers have sums that are LESS than the number and we don't need to test those.
        // We have to test ony up to 354,294.
        int sum = 0;
        for (int i = 2; i <= 354_294; i++) {
            if (i == sumOfPowerOfDigits(i, 5)) {
                //System.out.println(i);
                sum += i;
            }
        }

        return sum;
    }

    public long sumOfPowerOfDigits(int number, int power) {
        int sum = 0;
        int digit;
        while (number > 0) {
            //Get the "last" digit
            digit = number % 10;
            sum += (int) Math.pow(digit, power);
            //Integer divide of the number; 
            number = number / 10;
        }
        return sum;
    }

    public int problem31() {

        //In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation:
        //
        //    1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).
        //
        //It is possible to make £2 in the following way:
        //
        //    1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p
        //
        //How many different ways can £2 be made using any number of coins?
        //If we just used recursion we end up calculating things like "how many ways can I do 15 cents" several times
        //If we cache every solution we save many iterarions.  Turns out by using the cache we save 2463 "repeats".
        
        int [] coinDenominations = {1,2,5,10,20,50,100,200};
        HashMap<String, Integer> cache = new HashMap<>();

        //To start the problem we start with 200 (2 pounds) as the "largest coin"
        // and 200 pence "to go".  The cache is empty and it will fill itself while it runs.
        int value = countWays(7, 200, cache,coinDenominations);

        //System.out.println("Cache Size:" + cache.size());
        return value;

    }


    private int countWays(int maxCoinIndex, int remainder, HashMap<String, Integer> cache, int [] coinDenominations) {
        //This coin is the "current" coin on which we start, it should always start with the largest coin.
        //Reminder is how many more pence do we have to account for.

        //First check the cache to see if we already solved this one;
        String key = coinDenominations[maxCoinIndex] + ":" + remainder;
        if (cache.containsKey(key)) {
            return cache.get(key);
        }
        // if not in the cache go ahead and solve it and add it to the cache

        if ((maxCoinIndex == 0) || (remainder == 0)) {
            //if the "current" coin is 1 pence there is only way of delivering any amount with only 1 pence coins.
            //Also if you have reached the end of the calcuation -there is no reminder- you can return "1";

            //System.out.println(remainder + " coins of 1p.");
            cache.put(key, 1);
            return 1;
        } else {
            int sumWays = 0;
            
            //You can do 0, 1, 2, etc of "this coin" and "the rest" in "smaller coins"
            for (int i = 0; i * coinDenominations[maxCoinIndex] <= remainder; i++) {
                //System.out.print(i + " coins of " + thisCoin + ", ");
                sumWays += countWays(maxCoinIndex-1, remainder - i * coinDenominations[maxCoinIndex], cache, coinDenominations);
            }
            cache.put(key, sumWays);
            return sumWays;
        }
    }

    public int problem32() {

        //We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through 5 pandigital.
        //
        //The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.
        //
        //Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.
        //HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.em32() {
        //Since it has to be A*BCDE=FGHI, AB*CDE=FGHI all we need is all the 
        //permutations of 5 digits with 1 to 9.
        //Then we check if the product of 1 * 4 or 2 *3 "produce" the other 
        // missing 5.
        ArrayList<Integer> myValues = new ArrayList<>();
        for (int i = 1; i <= 9; i++) {
            myValues.add(i);
        }

        ArrayList<ArrayList> permutations = permutation(myValues, 5);

        ArrayList<Integer> products = new ArrayList<>();

        for (ArrayList list : permutations) {

            //Try the two options,  1 * 4 
            int a = Integer.valueOf(list.get(0).toString());

            int b = Integer.valueOf(list.get(1).toString()
                    + list.get(2).toString()
                    + list.get(3).toString()
                    + list.get(4).toString());

            if (isPandigital(a, b, a * b)) {
//                System.out.print (a);
//                System.out.print ( "x");
//                System.out.print ( b);
//                System.out.print ( "=");
//                System.out.println (a*b);

                if (!products.contains(a * b)) {
                    products.add(a * b);
                }
            }
            //and and 2 * 3

            a = Integer.valueOf(list.get(0).toString()
                    + list.get(1).toString());

            b = Integer.valueOf(list.get(2).toString()
                    + list.get(3).toString()
                    + list.get(4).toString());

            if (isPandigital(a, b, a * b)) {
//                System.out.print (a);
//                System.out.print ( "x");
//                System.out.print ( b);
//                System.out.print ( "=");
//                System.out.println (a*b);
                if (!products.contains(a * b)) {
                    products.add(a * b);
                }
            }

        }

        return products.stream().mapToInt(p -> p).sum();
        //return products.stream().reduce(0, Integer::sum);

    }

    public int problem32a() {
        //Pure brute force
        ArrayList<Integer> products = new ArrayList<>();

        //First the one by fours.
        for (int a = 1; a <= 9; a++) {
            for (int b = 1234; b <= 9876; b++) {
                if (isPandigital(a, b, a * b)) {
                    if (!products.contains(a * b)) {
                        products.add(a * b);
                    }
                }
            }
        }

        // next the two by threes
        for (int a = 12; a <= 98; a++) {
            for (int b = 123; b <= 987; b++) {
                if (isPandigital(a, b, a * b)) {
                    if (!products.contains(a * b)) {
                        products.add(a * b);
                    }
                }
            }
        }

        return products.stream().mapToInt(p -> p).sum();
        //return products.stream().reduce(0, Integer::sum);
    }

    private ArrayList<ArrayList> permutation(ArrayList items, int r) {

        //Return is an Array of Arrays
        ArrayList<ArrayList> returnValue = new ArrayList<>();

        if (r == 1) {
            //Copy each item into a "one item" array
            for (Object item : items) {
                ArrayList<Object> singleLine = new ArrayList<>();
                singleLine.add(item);
                returnValue.add(singleLine);
            }

        } else {

            int size = items.size();

            //For each item
            for (int i = 0; i < size; i++) {
                //Remove it
                Object curItem = items.get(i);
                items.remove(i);
                //Process the list without that item and get all the permutations
                ArrayList<ArrayList> shorterPerm = permutation(items, r - 1);

                //To each permutation "add" the item back
                shorterPerm.stream().map((perm) -> {
                    //Add the "removed" item at the beggining of each lline
                    perm.add(0, curItem);
                    return perm;
                }).forEach((perm) -> {
                    //Add that "new" line with the "extra item" to the results.
                    returnValue.add(perm);
                });

                //Put the item back and process the "next" item
                items.add(i, curItem);

            }
        }

        return returnValue;

    }

    private boolean isPandigital(int... values) {

        StringBuilder digits = new StringBuilder();

        for (int x : values) {
            digits.append(Integer.toString(x));
        }
        return isPandigital(digits.toString());
    }

    private boolean isPandigital(String value) {
        return isPandigital(value, false);
    }

    private boolean isPandigital(String value, boolean zeroBased) {

        if (value.length() > (zeroBased ? 10 : 9)) {

            return false;

        } else {
            for (int i = (zeroBased ? 0 : 1); i <= value.length(); i++) {
                if (!value.contains(Integer.toString(i))) {
                    return false;
                }
            }
            return true;
        }
    }

    public int problem33() {

        //
        //The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that 49/98 = 4/8, which is correct, is obtained by cancelling the 9s.
        //
        //We shall consider fractions like, 30/50 = 3/5, to be trivial examples.
        //
        //There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.
        //
        //If the product of these four fractions is given in its lowest common terms, find the value of the denominator.
        //The possible fractions likt the ones described look like 
        //AB/BC which "simplifies" to A/C 
        //AB/CA which "simplifies" to B/C 
        //all the options would take only 9^3 = 729 tries so brute force would be fast enough.
        //Use float to avoid int divisor in Java.
        int numerator = 1;
        int denominator = 1;

        for (float a = 1; a < 10; a++) {
            for (float b = 1; b <= 10; b++) {
                for (float c = 1; c <= 10; c++) {
                    //Try each case.
                    if ((a / c < 1) && ((10 * a + b) / (10 * b + c) == (a / c))) {
                        numerator *= a;
                        denominator *= c;

                    }

                    if ((b / c < 1) && ((10 * a + b) / (10 * c + a) == (b / c))) {
                        numerator *= b;
                        denominator *= c;
                    }
                }
            }
        }

        //Now reduce the fraction
        int maxFactor = (int) Math.ceil(Math.pow(denominator, 0.5));

        for (int i = 2; i <= maxFactor; i++) {
            boolean reduced = true;
            while (reduced) {
                reduced = false;
                if (((denominator % i) == 0) && ((numerator % i) == 0)) {
                    denominator /= i;
                    numerator /= i;
                    reduced = true;
                }
            }

        }

        return denominator;

    }

    public int problem34() {

        //145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.
        //
        //Find the sum of all numbers which are equal to the sum of the factorial of their digits.
        //
        //Note: as 1! = 1 and 2! = 2 are not sums they are not included
        //9! = 362,880 a 6 digit number. 
        //1 digit numbers will produce values between 1 and 1*362,880.           OK: Possible that it is a 1 digit #
        //2 digit numbers will produce values between 1 and 2*362,880=725,760.   OK: Possible that it is a 2 digit #
        //3 digit numbers will produce values between 1 and 3*362,880=1,088,640  OK: Possible that it is a 3 digit #
        //4 digit numbers will produce values between 1 and 4*362,880=1,451,520  OK: Possible that it is a 4 digit #
        //5 digit numbers will produce values between 1 and 5*362,880=1,814,400  OK: Possible that it is a 5 digit #
        //6 digit numbers will produce values between 1 and 6*362,880=2,177,280  OK: Possible that it is a 6 digit #
        //7 digit numbers will produce values between 1 and 7*362,880=2,540,160  OK: Possible that it is a 7 digit #
        //8 digit numbers will produce values between 1 and 8*362,880=2,903,040  Not possible to create an 8 digit #  So the numbers has to have less than 8 digits
        int sumOf = 0;
        //Start with 3 as we were told to ignore 1 and 2.
        for (int i = 3; i <= 2_540_161; i++) {
            if (isSumofFactorialofDigits(i)) {
                //System.out.println(i);
                sumOf += i;
            }
        }

        return sumOf;
    }

    private boolean isSumofFactorialofDigits(int n) {
        int target = n;
        int sumOfFactorials = 0;
        int nextDigit;
        while ((target > 0) && (sumOfFactorials <= n)) {
            nextDigit = target % 10;
            target /= 10;
            sumOfFactorials += factorial(nextDigit);
        }
        if (target > 0) {
            return false;
        }
        return sumOfFactorials == n;
    }

    public int problem35() {

        //The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.
        //
        //There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.
        //
        //How many circular primes are there below one million?
        long currentPrime = 2;
        int countOfCircularPrimes = 0;
        while (currentPrime < 1_000_000) {
            if (isCircularPrime(currentPrime)) {
                //System.out.println(currentPrime);
                countOfCircularPrimes++;
            }
            currentPrime = Primes.nextPrime(currentPrime);
        }
        return countOfCircularPrimes;
    }

    static int numlength(long n) {
        int l;
        n = Math.abs(n);
        for (l = 0; n > 0; ++l) {
            n /= 10;
        }
        return l;
    }

    public long circularShiftLeft(long value, int length) {
        //We need to pass on the expected length because without it 
        //when the number has a zero we will truncate it on the shifting.

        if (length == 1) {
            return value;
        } else {

            boolean negative = value < 0;
            if (negative) {
                value *= 1;
            }

            int numToMove = (int) (value / Math.pow(10, length - 1));
            long returnVal = (value % ((long) (Math.pow(10, length - 1)))) * 10 + numToMove;

            return negative ? -returnVal : returnVal;

        }

    }

    public boolean isCircularPrime(long n) {

        int tries = numlength(n);
        int size = tries;
        while (true) {
            if (!Primes.isPrime(n)) {
                return false;
            }
            tries--;
            if (tries > 0) {
                n = circularShiftLeft(n, size);
            } else {
                return true;
            }
        }

    }

    public int problem36() {

        //The decimal number, 585 = 1001001001 (binary), is palindromic in both bases.
        //Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.
        //(Please note that the palindromic number, in either base, may not include leading zeros.)
        //Have to test only odd numbers
        //Even numbers will end in "0" when converted to binary
        //Also have to eliminate multiples of ten but limited to odd does 
        //that as well
        int sumOfPalindromes = 0;
        for (int i = 1; i < 1_000_000; i += 2) {
            if (isPalindrome(Integer.toString(i)) && isPalindrome(Integer.toBinaryString(i))) {
                //System.out.println(i);
                sumOfPalindromes += i;
            }
        }

        return sumOfPalindromes;
    }

    

    public String intToBinary(int n) {

        //Same algorithm for any base between 2 and 9
        final int base = 2;
        //With minor changes for concatenating "A", "B",... instead of 10,11,.. could go for bases higher than 9

        StringBuilder answer = new StringBuilder();
        while (n > 0) {
            answer.append(Integer.toString(n % base));
            //you can skip this because Java does integer division
            //n-=n%base;
            n /= base;
        }

        return answer.reverse().toString();
    }

    public int problem37() {

        //The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.
        //
        //Find the sum of the only eleven primes that are both truncatable from left to right and right to left.
        //
        //NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.
        int count = 0;
        int sum = 0;
        long prime = 11;

        while (count < 11) {
            prime = Primes.nextPrime(prime);
            if (isTruncatblePrime(prime)) {
                //System.out.println(prime);
                sum += prime;
                count++;
            }

        }

        return sum;
    }

    public boolean isTruncatblePrime(long candidate) {

        if (candidate < 10) {
            return false;
        }

        long counterTrim = candidate;

        while (candidate > 0) {
            if (Primes.isPrime(candidate) && Primes.isPrime(counterTrim)) {

                //Trim left ro right
                candidate %= (Math.pow(10, numlength(candidate) - 1));

                //Trim right to left.
                counterTrim /= 10;
            } else {
                return false;
            }
        }
        return true;

    }

    public int problem38() {

        //Take the number 192 and multiply it by each of 1, 2, and 3:
        //
        //    192 × 1 = 192
        //    192 × 2 = 384
        //    192 × 3 = 576
        //
        //By concatenating each product we get the 1 to 9 pandigital, 192384576. We will call 192384576 the concatenated product of 192 and (1,2,3)
        //
        //The same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and 5, giving the pandigital, 918273645, which is the concatenated product of 9 and (1,2,3,4,5).
        //
        //What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2, ... , n) where n > 1?
        //BruteForce
        //Since it has to be n> 2 the largerst pandigital can only be as large as [abcd][abcd*2] so abcd has to be at most 4 digits since a 5 + 5 would be > 9 digits. 
        int maxValue = 0;

        for (int a = 1; a < 100_000; a++) {

            StringBuilder digits = new StringBuilder(Integer.toString(a));

            //We start multiplying by integers and concatenating until the 
            //string is at least 9 chars.
            int multiplier = 2;
            while (digits.length() < 9) {
                digits.append(Integer.toString(a * multiplier));
                multiplier++;
            }

            //Now lets see if the string is pandigital
            if (isPandigital(digits.toString())) {
                int curVal = Integer.valueOf(digits.toString());
                if (curVal > maxValue) {
                    maxValue = curVal;
                }
            }

        }
        return maxValue;
    }

    public int problem39() {

        //If p is the perimeter of a right angle triangle with integral length sides, {a,b,c}, there are exactly three solutions for p = 120.
        //
        //{20,48,52}, {24,45,51}, {30,40,50}
        //
        //For which value of p ≤ 1000, is the number of solutions maximised?
        //rather than trying to figure out all the solutions for a given p
        //try all the possible right angle triangles with integer sides that add 
        //to less than a 1000 and figure out the "p" with most solutions.
        //the most "extreme" triangle with integer sides with "p" less than
        //1000 would be {499, 499, 1} (not a right angle one though.
        //we can limit our search space for sides between 1 and 499.
        //Since {20,48,52} is the same as {48,20,52} lets assume that a <= b
        //perimiters(permiterSize,countOfTrianglesWithThatPerimeter)
        HashMap<Integer, Integer> perimeters = new HashMap<>();

        int MaxCount = 0;
        int MaxP = 0;

        for (int a = 1; a < 500; a++) {
            for (int b = a; b < 500; b++) {
                //Compute C for the given a and b
                int c = (int) Math.floor(Math.sqrt(a * a + b * b));

                //Check if the conversion didn't truncate anything 
                //i.e. C is interger
                if (c * c == a * a + b * b) {

                    //Now lets see if its p <= 1000
                    if (a + b + c <= 1000) {

                        int value;
                        if (perimeters.containsKey(a + b + c)) {
                            value = perimeters.get(a + b + c);
                            value++;
                        } else {
                            value = 1;
                        }

                        if (value > MaxCount) {
                            //Rather than searching later just keep track now
                            MaxCount = value;
                            MaxP = a + b + c;
                            //System.out.println(String.format("MAX {%d,%d,%d}:%d:count%d", a, b, c, MaxP, MaxCount));
                        }

                        perimeters.put(a + b + c, value);
                        //System.out.println(String.format("{%d,%d,%d}", a, b, c));
                    }
                }
            }
        }

        return MaxP;

    }

    public int problem40() {

        //An irrational decimal fraction is created by concatenating the positive integers:;
        //
        //0.123456789101112131415161718192021...
        //
        //It can be seen that the 12th digit of the fractional part is 1.
        //
        //If dn represents the nth digit of the fractional part, find the value of the following expression.
        //
        //d1 × d10 × d100 × d1,000 × d10,000 × d100,000 × d1,000,000
        //Brute force.  Just create the string
        StringBuilder longDigits = new StringBuilder(1_000_000);
        int i = 1;
        while (longDigits.length() < 1_000_000) {
            longDigits.append(Integer.toString(i++));
        }

        //Now to find the answer by looking into the string.
        int prod = 1;
        int charPos;
        for (int p = 0; p <= 6; p++) {
            charPos = (int) Math.pow(10, p) - 1;
            //System.out.println(longDigits.charAt(charPos));
            prod *= Integer.valueOf(longDigits.substring(charPos, charPos + 1));
        }

        return prod;

    }

    public int problem40a() {

        int prod = 1;
        int charPos;

        for (int p = 0; p <= 6; p++) {
            charPos = (int) Math.pow(10, p);
            //System.out.println(findDigitAtPosition(charPos));
            prod *= findDigitAtPosition(charPos);
        }

        return prod;

    }

    private int findDigitAtPosition(int n) {
        // Lets find out if the n value is on the one 1 digit group, or 2 , or 3 digit etc.

        //Let the string include the 0 so it is 0.12345678910
        //in other words the string is zero based.
        //First 10 digits are 1 digit numbers - 10 * 1 = 10 -> 10
        //Next 90 digits are 2 digit numbers - 90 * 2 = 180 - > 190
        //Next 900 digits are 3 digit numbers  - 900 * 3 = 2_700 -> 2890
        //Next 9_000 digits are 4 digit numbers - 9_000 * 4 =  36_000 ->  38_890...
        //Lets remove all the 1 digits, then 2 digits, then 3 digts, etc
        //until we get to the group of n-digits that represents our number
        if (n < 10) {
            return n;
        } else {

            int digitCount = 1;
            int digitsToRemove = 10;

            while (n > digitsToRemove) {
                n -= digitsToRemove;
                digitsToRemove = 9 * (int) Math.pow(10, digitCount) * (digitCount + 1);
                digitCount++;
            }

            //Now that we have removed all the strings of less than "digitsToRemove"
            //The new problem is limited to strings of "digitCount" digits.
            //on position (n)
            //Find which number this falls into
            int answer = (n / digitCount) + (int) Math.pow(10, digitCount - 1);

            //And what digit within that answer
            int posinAnswer = n % digitCount;

            //Now just "Shift" the answer to "pos in Answer"
            //Trim away all the "lower" values so our digit is in the "units"
            answer /= (int) Math.pow(10, digitCount - posinAnswer - 1);

            //Just return the units.
            return answer % 10;

        }

    }

    public int problem41() {

        //We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once. 
        //For example, 2143 is a 4-digit pandigital and is also prime.
        //What is the largest n-digit pandigital prime that exists?
        //Since 1+2+3+4+5+6+7+8+9 is divible over 3 it can't be 9 digits
        //same for 1 to 8.
        for (int i = 7654321; i >= 2143; i -= 2) {
            if (isPandigital(Integer.toString(i))) {
                if (Primes.isPrime(i)) {
                    return i;
                }
            }
        }
        //Fallback;
        return 2143;
    }

    public int problem42() {

        //The nth term of the sequence of triangle numbers is given by, tn = n(n+1)/2; so
        //the first ten triangle numbers are:
        //
        //1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
        //
        //By converting each letter in a word to a number corresponding to its alphabetical
        //position and adding these values we form a word value. For example, the word value
        //for SKY is 19 + 11 + 25 = 55 = t10. If the word value is a triangle number then we
        //shall call the word a triangle word.
        //
        //Using words.txt (right click and 'Save Link/Target As...'), a 16K text file
        //containing nearly two-thousand common English words, how many are triangle words?
        //This part is boiler plate for reading the text file.
        Path path = FileSystems.getDefault().getPath("./src", "p042_words.txt");
        ArrayList<String> words = new ArrayList<>();
        try {
            //Split the single line on "," and then remove the quotations.
            List<String> lines = Files.readAllLines(path, Charset.defaultCharset());
            lines.stream().map((line) -> line.split(",")).forEach((values) -> {
                for (String word : values) {
                    words.add(word.replace("\"", ""));
                }
            });
        } catch (IOException ex) {
            Logger.getLogger(Problems001to050.class.getName()).log(Level.SEVERE, null, ex);
        }

        //Now we have the words in an Arraylist.
        //Filter using Lambda expression
        //and count the result. 
        return (int) words.stream().filter((word) -> {
            //Use a lambda to convert a word into its numeric values
            int alphaValue = word.toUpperCase().chars().map((character) -> {
                //Simply uppercase the word and substract 64 from each code since
                //A = 64 in ASCII
                return character - 64;
            }).sum();
            int a = (int) Math.floor(Math.sqrt(alphaValue * 2));
            return 2 * alphaValue == a * (a + 1);
        }).count();

    }

    public long problem43() {

        //The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, but it also has a rather interesting sub-string divisibility property.
        //
        //Let d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we note the following:
        //
        //    d2d3d4=406 is divisible by 2
        //    d3d4d5=063 is divisible by 3
        //    d4d5d6=635 is divisible by 5
        //    d5d6d7=357 is divisible by 7
        //    d6d7d8=572 is divisible by 11
        //    d7d8d9=728 is divisible by 13
        //    d8d9d10=289 is divisible by 17
        //
        //Find the sum of all 0 to 9 pandigital numbers with this property.
        
        //This is a very inneficient way of doing this.  See 43a for something better.
        ArrayList<String> perms = Utilities.permutations("0123456789");

        return perms.stream().filter(p -> (Integer.valueOf(p.substring(1, 4)) % 2 == 0)
                && (Integer.valueOf(p.substring(2, 5)) % 3 == 0)
                && (Integer.valueOf(p.substring(3, 6)) % 5 == 0)
                && (Integer.valueOf(p.substring(4, 7)) % 7 == 0)
                && (Integer.valueOf(p.substring(5, 8)) % 11 == 0)
                && (Integer.valueOf(p.substring(6, 9)) % 13 == 0)
                && (Integer.valueOf(p.substring(7, 10)) % 17 == 0)
        ).mapToLong(Long::valueOf).sum();

    }

    

    public long problem43a() {

        int i = 1;
        long sum = 0;
        //will handle the 17th on the outer loop, the others in a recursive function.

        //The other divisors will be handled by the recursive function, 
        //they will be in an array and the array size will determine the
        //level of recursion.
        int divisors[] = {13, 11, 7, 5, 3, 2};
        while (i * 17 < 999) {   //Lets create numbers divisible by 17, 
            StringBuilder candidate = new StringBuilder(10);
            candidate.append(Integer.toString(i * 17));

            //Add "0" if needed.
            if (candidate.length() != 3) {
                candidate.insert(0, "0");
            }
            //Lets not bother with the ones that have duplicate digits
            if (candidate.chars().distinct().count() == candidate.length()) {
                sum += sumPandigitals(divisors, 0, candidate.toString());
            }
            i++;

        }
        return sum;
    }

    private long sumPandigitals(int[] divisors, int pos, String candidate) {
        if (pos == divisors.length) {
            //We now have a 9 digit number, need to find the "missing" digit            
            //no need to bother with "0"
            for (int a = 1; a < 10; a++) {
                if (!candidate.contains(Integer.toString(a))) {
                    return Long.valueOf(Integer.toString(a).concat(candidate));
                }
            }
            return 0;
        } else {
            long answer = 0L;
            //Try the "remaining" digits.
            for (int a = 0; a < 10; a++) {
                if (!candidate.contains(Integer.toString(a))) {
                    if ((a * 100 + Integer.valueOf(candidate.substring(0, 2))) % divisors[pos] == 0) {
                        answer += sumPandigitals(divisors, pos + 1, Integer.toString(a).concat(candidate));
                    }
                }
            }
            return answer;
        }

    }

    public int problem44() {

        //
        //Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
        //
        //1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
        //
        //It can be seen that P4 + P7 = 22 + 70 = 92 = P8. 
        //However, their difference, 70 − 22 = 48, is not pentagonal.
        //
        //Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference 
        //are pentagonal and D = |Pk − Pj| is minimised; what is the value of D?
        //Create a function to create pentagonl numbers
        IntToLongFunction pentagonal = n -> n * (3 * n - 1) / 2;

        boolean found = false;
        int i = 2; //Since we will look down no need to start with less than 1.

        int minD = Integer.MAX_VALUE;
        long pi, pj;
        pi = 0;
        pj = 0;

        while (!found) {
            pi = pentagonal.applyAsLong(i); //This will be the upper bound
            for (int j = i - 1; j > 0; j--) {
                pj = pentagonal.applyAsLong(j);
                if (isPentagonal(pi + pj) && isPentagonal(pi - pj)) {

                    //We now have a solution but we don't 
                    //yet know if it is the smallest one.
                    minD = (int) (pi - pj);
                    found = true;
                    break; // out of the for loop
                }
            }
            i++;
        }

        return minD;
    }

    public long problem45() {

        //Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
        //Triangle 	  	Tn=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
        //Pentagonal 	  	Pn=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
        //Hexagonal 	  	Hn=n(2n−1) 	  	1, 6, 15, 28, 45, ...
        //
        //It can be verified that T285 = P165 = H143 = 40755.
        //
        //Find the next triangle number that is also pentagonal and hexagonal.
        
        //Lets just start with Hexagonal number of H144 and keep going looking for
        //values that are also triangular and pentagonal.
        IntToLongFunction hexagonal = n -> n * (2 * n - 1);

        int n = 144;
        long value;

        while (true) {
            value = hexagonal.applyAsLong(n);
            if (isPentagonal(value) && isTriangular(value)) {
                return value;
            }
            n++;
        }

    }

    private boolean isPentagonal(long n) {
        //Create a function to check for "pentagonnes" in a number.
        //Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2.
        //The inverse function is 
        // n = (sqrt(24x+1) + 1)/6
        return Utilities.isInteger((Math.sqrt(n * 24 + 1) + 1) / 6);
    }

    private boolean isTriangular(long n) {
        
        //Create a function to check for "triangularness" in a number.
        //Triangular numbers are generated by the formula, Tn=n(n+1)/2.
        //The inverse function is 
        // n = (sqrt(8x+1) - 1)/2
        
        return Utilities.isInteger((Math.sqrt(n * 8 + 1) - 1) / 2);
    }

    public int problem46() {

        //It was proposed by Christian Goldbach that every odd composite number 
        //can be written as the sum of a prime and twice a square.
        //
        //9 = 7 + 2×1^2
        //15 = 7 + 2×2^2
        //21 = 3 + 2×3^2
        //25 = 7 + 2×3^2
        //27 = 19 + 2×2^2
        //33 = 31 + 2×1^2
        //
        //It turns out that the conjecture was false.
        //
        //What is the smallest odd composite that cannot be written as the sum 
        //of a prime and twice a square?
        int candidate = 9;

        while (true) {
            if (!Primes.isPrime(candidate)) {
                //See if this value can be written 
                //as the sum of a prime and twice a square
                //Try with all primes smaller or equal to han candidate -2;
                long prime = 2;
                boolean found = false;
                while (prime <= candidate - 2) {
                    if (isInteger(Math.sqrt((candidate - prime) / 2.0))) {
                        found = true;
                        break;
                    } else {
                        prime = Primes.nextPrime(prime);
                    }
                }
                if (!found) {
                    return candidate;
                }
            }
            candidate += 2;
        }
    }


    public long problem47() {

        
        Predicate<Long> hasFourPrimes;
        
        hasFourPrimes = p -> {
            HashMap<Long, Long> factors = calculatePrimeFactors(p);
            return factors.size() == 4;
        };

        long candidate = 2 * 3 * 4 * 5; //The smallest number with four distinct primes factors
        int consecutiveCount = 1;

        while (consecutiveCount < 4) {
            if (hasFourPrimes.test(candidate)) {
                consecutiveCount++;
            } else {
                consecutiveCount = 0;
            }
            candidate++;
        }
        return candidate - 4;
    }

    public long problem48() {

        //The series, 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317.
        //
        //Find the last ten digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.
        BigInteger value = BigInteger.ZERO;
        BigInteger toAdd;
        for (int i = 1; i < 1000; i++) {
            toAdd = BigInteger.valueOf(i);
            value = value.add(toAdd.pow(i));
        }

        //Now trim to the last ten digits.
        toAdd = BigInteger.TEN;

        return value.mod(toAdd.pow(10)).longValue();
    }

    public long problem48a() {
        //We can use long and truncate all values over 10^10

        long sum = 0L;

        for (int i = 1; i < 1000; i++) {
            sum = (sum + Utilities.truncatedPow(i, i)) % 10_000_000_000L;
        }

        return sum;
    }

    

    public long problem49() {

        //The arithmetic sequence, 1487, 4817, 8147, in which each of the terms 
        //increases by 3330, is unusual in two ways: (i) each of the three terms
        //are prime, and, (ii) each of the 4-digit numbers are permutations of one another.
        //
        //There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, 
        //exhibiting this property, but there is one other 4-digit increasing sequence.
        //
        //What 12-digit number do you form by concatenating the three terms in this sequence?
        ArrayList<Integer> fourDigitPrimes = new ArrayList<>();

        //Add all the four digit primes into the array:
        int primeNum = (int) Primes.nextPrime(999);

        while (primeNum < 10_000) {
            fourDigitPrimes.add(primeNum);
            primeNum = (int) Primes.nextPrime(primeNum);
        }

        //Find two that are a permutation
        for (int i = 0; i < fourDigitPrimes.size() - 3; i++) {

            for (int j = i + 1; j < fourDigitPrimes.size() - 2; j++) {
                int a = fourDigitPrimes.get(i);
                int b = fourDigitPrimes.get(j);

                //Check to see its not the "give" answer.
                //Consider a==1487 and b <=4817 
                if (a == 1487 && b == 4817) {
                    break;
                }

                //See if they are permutations.
                if (isPermutationString(a, b)) {
                    //We found two, now lets see the difference 
                    int diff = b - a;
                    //Check to see if the next one is prime and also a permuattion
                    if (isPermutationString(a, b + diff) && fourDigitPrimes.contains(b + diff)) //Check the next one
                    {

                        return a * 10_000L * 10_000 + b * 10_000L + b + diff;

                    }

                }
            }
        }

        return 0;
    }

    

    public long problem50() {

        //The prime 41, can be written as the sum of six consecutive primes:
        //41 = 2 + 3 + 5 + 7 + 11 + 13
        //
        //This is the longest sum of consecutive primes that adds to a prime below one-hundred.
        //
        //The longest sum of consecutive primes below one-thousand that adds to a 
        //prime, contains 21 terms, and is equal to 953.
        //
        //Which prime, below one-million, can be written as the sum of the most 
        //consecutive primes?
        final int limit = 1_000_000;

        ArrayList<Integer> primes = new ArrayList<>();

        int a = 0, b = 2;

        while (a + b < limit) {
            a = b;
            primes.add(a);
            b = (int) Primes.nextPrime(a);
        }
        int globalMaxChain = 0;
        long globalMaxVal = 0;

        //Lets do for the first one
        for (int i = 0; i < primes.size(); i++) {
            long sum = primes.get(i);
            int localMaxChain = 1;
            long localMaxVal = 0;
            for (int j = 1; i + j < primes.size() && sum < limit; j++) {
                sum += primes.get(i + j);
                if (sum < limit && Primes.isPrime(sum)) {
                    localMaxChain = j + 1;
                    localMaxVal = sum;
                }
            }
            if (globalMaxChain < localMaxChain) {
                globalMaxChain = localMaxChain;
                globalMaxVal = localMaxVal;
            }
        }
        //System.out.println(String.format("MaxVal is %d for a chain of %d", globalMaxVal, globalMaxChain));

        return globalMaxVal;
    }
    
    
     
     
}
